<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浏览器的多个选项卡中共享sessionStorage]]></title>
    <url>%2F2018%2F06%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E4%B8%AA%E9%80%89%E9%A1%B9%E5%8D%A1%E4%B8%AD%E5%85%B1%E4%BA%ABsessionStorage%2F</url>
    <content type="text"><![CDATA[原文：Sharing sessionStorage between tabs for secure multi-tab authentication 使用场景在web项目中，当用户重开一个标签页的时候，需要重新登录。造成这种情况的是登录的标识符存取在session中，标签页之间没有共享session数据。 解决方式发现国外开发者解决的方式是监听storage事件，利用localStorage事件来跨标签页共享sessionStorage。在线例子 123456789101112131415161718192021222324252627282930313233343536// Removed IE support in this demo for the sake of simplicity// 移除对IE浏览器的支持(function () &#123; if (!sessionStorage.length) &#123; // Ask other tabs for session storage // 新开的标签页触发这个事件 localStorage.setItem(&apos;getSessionStorage&apos;, Date.now()); &#125;; window.addEventListener(&apos;storage&apos;, function (event) &#123; //console.log(&apos;storage event&apos;, event); if (event.key == &apos;getSessionStorage&apos;) &#123; // Some tab asked for the sessionStorage -&gt; send it // 已存在的标签页会接收到这个事件 localStorage.setItem(&apos;sessionStorage&apos;, JSON.stringify(sessionStorage)); localStorage.removeItem(&apos;sessionStorage&apos;); &#125; else if (event.key == &apos;sessionStorage&apos; &amp;&amp; !sessionStorage.length) &#123; // sessionStorage is empty -&gt; fill it // 新开启的标签页会收到这个事件 var data = JSON.parse(event.newValue), value; for (key in data) &#123; sessionStorage.setItem(key, data[key]); &#125; showSessionStorage(); &#125; &#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 提交表单后清空表单内的数据]]></title>
    <url>%2F2018%2F06%2F12%2Fvue-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E6%B8%85%E7%A9%BA%E8%A1%A8%E5%8D%95%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[应用场景在使用vue的框架中，常常出现提交完表单之后，data对象中表单的字段的数据还是存在的，做重复表单提交的过程中不是很友好，如果两个表单中存在公用的组件（组件C），如果这个表单（表单A）的数据没有清空，再跳转到另外一个表单（表单B）的时候，表单A上的组件C上的数据会出现到表单B的组件C上。 解决方式参考vue的API文档，发现我们可以通过$options获取初始化的data对象，在表单提交成功之后或者在vue生命周期的beforeDestroy、destroyed中可以通过 1this.form=Object.assign(&#123;&#125;,this.$options.data().form) 来初始化data对象的form字段。具体代码如下：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中常见的坑]]></title>
    <url>%2F2018%2F05%2F03%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[本地运行跨域问题通过webpack-dev-server的proxy来解决api接口请求跨域的问题，在dev的index.js文件中，设置proxy 123456789proxyTable: &#123; '/api': &#123; target: 'http://baidu.com/', changeOrigin: true, pathRewrite: &#123; '^/api': '/' &#125; &#125;&#125;, 在axios的中设置 1axios.defaults.baseURL = "/api"; vue操作DOM在created()钩子函数执行的时候进行的DOM操作，发现并未进行任何渲染，在查看Vue官方文档中，发现可以在Vue生命周期的created()钩子函数中通过在Vue.nextTick()的回调函数中进行的DOM操作，或者在mounted钩子函数直接进行DOM操作 element uiTable在element ui的table中，如果想去修改某一行的数据，如果直接将它复制给data对象里的一个属性，当修改某个字段时，会发现table里对应某行字段的数据也会发生改变，产生的原因时一个objec引用类型共享一个内存区域的，所以我们就不能直接连等复制，需要重新指向一个新的引用 1234567891011//赋值对象是一个objectthis.objData=Object.assign(&#123;&#125;, row)或this.objData=&#123;...row&#125;//赋值对象是一个arraynewArray = oldArray.slice()或newArray = oldArray.concat()或newArray = [...oldArray] el-table-column中格式化数据，可以通过formatter属性来绑定一个方法去写格式化数据，或者vue的计算属性computed 在每个el-table-column中通过设置min-width来适应不同大小的屏幕 input在el-input中通过添加.native 修饰符来触发input的原生事件 1&lt;el-input @click.native=&quot;handlenClick&quot;&gt;Click Me&lt;/el-input&gt; 修改element样式可以通过新建一个样式文件，在mian.js里引入 mint uiMessage box在用户的反馈中，ios8.1.2的微信浏览器中会出现提示框出现偏离的状况，修复问题中发现.mint-msgbox的样式中transform: translate3d(-50%,-50%,0);没有起作用，通过引入全局样式 1234567.mint-msgbox&#123; max-width: 84%; top: 35%; left: 8%; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 微信JSSDK签名出错在vue-router的对象实例中设置了mode: ‘history’，会在使用this.$router.push跳转需要调用微信JSSDK的页面中，会签名出错，解决的方式有 1234//方案一通过location.href来跳转需要调用微信JSSDK的页面//方案二vue-router使用hash模式 在真机上进行调试通过在main.js引入vConsole.js来查看api接口请求的数据]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装NPM registry管理工具--nrm]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%AE%89%E8%A3%85NPM-registry%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-nrm%2F</url>
    <content type="text"><![CDATA[安装nrm开发的npm registry 管理工具 nrm, 能够查看和切换当前使用的registry。github 1$ npm install -g nrm 查看当前使用的NPM registry123456789$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 切换NPM registry1$ nrm use cnpm]]></content>
      <categories>
        <category>Mac</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 通过brew安装指定版本的node]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E9%80%9A%E8%BF%87brew%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84node%2F</url>
    <content type="text"><![CDATA[安装NVM前提是安装了homebrew 1$ brew install nvm 在终端中输入以下命令 1$ vim ~/.zshrc 然后添加以下命令 12export NVM_DIR=&quot;$HOME/.nvm&quot;. &quot;/usr/local/opt/nvm/nvm.sh&quot; 最后推出vim，输入以下命令 1$ source ~/.zshrc 使用nvm安装指定版本的node1234567$ nvm ls-remote 查看 所有的node可用版本$ nvm install 8.9.4 下载你想要的版本,这里的8.9.4指的是node的版本$ nvm use 8.9.4 使用指定版本的node $ nvm alias default 8.9.4 每次启动终端都使用该版本的node 查看你的node和npm的版本123$ node -v$ npm -v 查看npm全局安装的modules(模块)1$ npm list --depth=0 -global]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 程序猿软件推荐一波]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[Web编程软件 WebStorm VS Code Sublime Text 使用过程中，我感觉WebStorm和VS Code所占用的内存差不多，但是个人认为还是WebStorm会更好一点，Sublime可以用来快速的查看代码,顺便安利一波使用命令开启VS Code和Sublime来打开项目 VS Code通过终端输入下面命令 1$ vim ~/.zshrc 在把下面命令加上 1234567alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos;alias subl=&quot;&apos;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&apos;&quot;alias nano=&quot;subl&quot;export EDITOR=&quot;subl&quot; 代码版本控制可视化工具 svn: Cornerstone git: Sourcetree HomebrewmacOS 缺失的软件包管理器打开终端输入以下命令 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 其他开发利器 终端: iTerm Docker 软件快速切换: Alfred SSH: Termius 视频播放器: IINA FTP: FileZilla Mac清理软件: Dr. Cleaner]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 使用Promise封装wx.request]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85wx-request%2F</url>
    <content type="text"><![CDATA[wx.request微信小程序原生的网络请求API 12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) Promise使用Promise封装wx.request,在发起一个请求之前使用wx.showToast()，在接口调用结束的complete回调函数中使用wx.hideToast() 1234567891011121314151617181920212223242526272829303132const wxRequest = (params = &#123;&#125;, url) =&gt; &#123; wx.showToast(&#123; title: '加载中...', icon: 'loading', duration: 5000 &#125;) let data = params.query || &#123;&#125;; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: url, method: params.method || 'GET', data: data, header: &#123; 'Content-Type': 'application/json' &#125;, success: res=&gt; &#123; if (res.data.status == 'success') &#123; resolve(res.data) &#125; else &#123; reject(res.msg) &#125; &#125;, complete:()=&gt;&#123; wx.hideToast() &#125;, error: e=&gt; &#123; reject(e) &#125; &#125;) &#125;)&#125;module.exports = &#123; wxRequest,&#125; 如何使用编写一个项目的时候，最好把所有的API接口集合一个js文件中 123456789101112const http = require("../utils/http.js")const baseUrl = 'http://127.0.0.1:8888/Wxxcx'const getUnionId = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getWxUserInfo`)const getLatLng = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getStationList`)const getOil = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getOilGun`)module.exports = &#123; getUnionId, getLatLng, getOil&#125; 接着，在pages中对应页面的js文件中引入 1234567891011121314const api = require('../../api/api.js')在对应的生命周期函数中写入api.getUnionId(&#123; query: &#123; code: app.globalData.code, iv: res.iv, encryptedData: res.encryptedData &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 参考资料 微信小程序 ECMAScript 6 入门]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
