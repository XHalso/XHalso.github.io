<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript中浅拷贝和深拷贝]]></title>
    <url>%2F2018%2F08%2F02%2Fjavascript%E4%B8%AD%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[javascript的变量类型 基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。 引用类型：存放在堆内存中的对象，变量实际保存的是一个内存地址，这个内存地址指向另一个内存空间。每个空间大小不一样，要根据情况开进行特定的分配。 当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的内存地址，然后再从堆内存中取得所需的数据。 javascript存储对象都是存地址的，所以浅拷贝会导致 arr1 和arr2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;2&apos;;console.log(arr1); //2,2,3console.log(arr2); //2,2,3 浅拷贝简单的引用复制12345678910111213141516var a = &#123; key1: &quot;11111&quot;&#125;function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125;a.key2 = [&apos;小辉&apos;, &apos;小辉&apos;];var b = Copy(a);b.key2.push(&quot;大辉&quot;);console.log(b.key2); //小辉，小辉，大辉console.log(a.key2); //小辉，小辉，大辉 a对象中key1属性是字符串，key2属性是数组。a拷贝到b，key1、key2属性均顺利拷贝。给b对象的key2属性进行修改时，a对象的key2属性也会随之改变。说明a，b对象上的key2属性指向的是同一个内存地址（x1），当对b对象的key2属性进行修改时，实际上是修改的x1指向的内存空间。 123b.key1 = 1;console.log(b.key1); //1console.log(1.key1); //11111 给b对象的key1属性进行修改时，a对象的key1属性不会改变。这是由于a，b对象的key1属性都是基本数据类型，会直接存储在内存中，b对象的key1的修改不会对a对象的key1产生影响。其在内存的状态，可以用下图来表示。 深拷贝递归遍历123456789101112131415161718function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125;a.key2 = [&apos;小辉&apos;, &apos;小辉&apos;];var b = &#123;&#125;;b = deepCopy(a, b);b.key2.push(&quot;大辉&quot;);alert(b.key2); //小辉，小辉，大辉alert(a.key2); //小辉，小辉 由上可知，修改b的key2数组时，没有使a父对象中的key2数组新增一个值，即子对象没有影响到父对象a中的key2。其存储模式大致如下： Array的slice和concat方法Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。例子如下： 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringifyJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 1234567891011121314151617181920//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。还有一点不好的地方是它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。同时如果对象中存在循环引用的情况也无法正确处理。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的多个选项卡中共享sessionStorage]]></title>
    <url>%2F2018%2F06%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E4%B8%AA%E9%80%89%E9%A1%B9%E5%8D%A1%E4%B8%AD%E5%85%B1%E4%BA%ABsessionStorage%2F</url>
    <content type="text"><![CDATA[原文：Sharing sessionStorage between tabs for secure multi-tab authentication 使用场景在web项目中，当用户重开一个标签页的时候，需要重新登录。造成这种情况的是登录的标识符存取在session中，标签页之间没有共享session数据。 解决方式发现国外开发者解决的方式是监听storage事件，利用localStorage事件来跨标签页共享sessionStorage。在线例子 123456789101112131415161718192021222324252627282930313233343536// Removed IE support in this demo for the sake of simplicity// 移除对IE浏览器的支持(function () &#123; if (!sessionStorage.length) &#123; // Ask other tabs for session storage // 新开的标签页触发这个事件 localStorage.setItem(&apos;getSessionStorage&apos;, Date.now()); &#125;; window.addEventListener(&apos;storage&apos;, function (event) &#123; //console.log(&apos;storage event&apos;, event); if (event.key == &apos;getSessionStorage&apos;) &#123; // Some tab asked for the sessionStorage -&gt; send it // 已存在的标签页会接收到这个事件 localStorage.setItem(&apos;sessionStorage&apos;, JSON.stringify(sessionStorage)); localStorage.removeItem(&apos;sessionStorage&apos;); &#125; else if (event.key == &apos;sessionStorage&apos; &amp;&amp; !sessionStorage.length) &#123; // sessionStorage is empty -&gt; fill it // 新开启的标签页会收到这个事件 var data = JSON.parse(event.newValue), value; for (key in data) &#123; sessionStorage.setItem(key, data[key]); &#125; showSessionStorage(); &#125; &#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 提交表单后清空表单内的数据]]></title>
    <url>%2F2018%2F06%2F12%2Fvue-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E6%B8%85%E7%A9%BA%E8%A1%A8%E5%8D%95%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[应用场景在使用vue的框架中，常常出现提交完表单之后，data对象中表单的字段的数据还是存在的，做重复表单提交的过程中不是很友好，如果两个表单中存在公用的组件（组件C），如果这个表单（表单A）的数据没有清空，再跳转到另外一个表单（表单B）的时候，表单A上的组件C上的数据会出现到表单B的组件C上。 解决方式参考vue的API文档，发现我们可以通过$options获取初始化的data对象，在表单提交成功之后或者在vue生命周期的beforeDestroy、destroyed中可以通过 1this.form=Object.assign(&#123;&#125;,this.$options.data().form) 来初始化data对象的form字段。具体代码如下：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中常见的坑]]></title>
    <url>%2F2018%2F05%2F03%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[本地运行跨域问题通过webpack-dev-server的proxy来解决api接口请求跨域的问题，在dev的index.js文件中，设置proxy 123456789proxyTable: &#123; '/api': &#123; target: 'http://baidu.com/', changeOrigin: true, pathRewrite: &#123; '^/api': '/' &#125; &#125;&#125;, 在axios的中设置 1axios.defaults.baseURL = "/api"; vue操作DOM在created()钩子函数执行的时候进行的DOM操作，发现并未进行任何渲染，在查看Vue官方文档中，发现可以在Vue生命周期的created()钩子函数中通过在Vue.nextTick()的回调函数中进行的DOM操作，或者在mounted钩子函数直接进行DOM操作 element uiTable在element ui的table中，如果想去修改某一行的数据，如果直接将它复制给data对象里的一个属性，当修改某个字段时，会发现table里对应某行字段的数据也会发生改变，产生的原因时一个objec引用类型共享一个内存区域的，所以我们就不能直接连等复制，需要重新指向一个新的引用 1234567891011//赋值对象是一个objectthis.objData=Object.assign(&#123;&#125;, row)或this.objData=&#123;...row&#125;//赋值对象是一个arraynewArray = oldArray.slice()或newArray = oldArray.concat()或newArray = [...oldArray] el-table-column中格式化数据，可以通过formatter属性来绑定一个方法去写格式化数据，或者vue的计算属性computed 在每个el-table-column中通过设置min-width来适应不同大小的屏幕 input在el-input中通过添加.native 修饰符来触发input的原生事件 1&lt;el-input @click.native=&quot;handlenClick&quot;&gt;Click Me&lt;/el-input&gt; 修改element样式可以通过新建一个样式文件，在mian.js里引入 mint uiMessage box在用户的反馈中，ios8.1.2的微信浏览器中会出现提示框出现偏离的状况，修复问题中发现.mint-msgbox的样式中transform: translate3d(-50%,-50%,0);没有起作用，通过引入全局样式 1234567.mint-msgbox&#123; max-width: 84%; top: 35%; left: 8%; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 微信JSSDK签名出错在vue-router的对象实例中设置了mode: ‘history’，会在使用this.$router.push跳转需要调用微信JSSDK的页面中，会签名出错，解决的方式有 1234//方案一通过location.href来跳转需要调用微信JSSDK的页面//方案二vue-router使用hash模式 在真机上进行调试通过在main.js引入vConsole.js来查看api接口请求的数据]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装NPM registry管理工具--nrm]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%AE%89%E8%A3%85NPM-registry%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-nrm%2F</url>
    <content type="text"><![CDATA[安装nrm开发的npm registry 管理工具 nrm, 能够查看和切换当前使用的registry。github 1$ npm install -g nrm 查看当前使用的NPM registry123456789$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 切换NPM registry1$ nrm use cnpm]]></content>
      <categories>
        <category>Mac</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 通过brew安装指定版本的node]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E9%80%9A%E8%BF%87brew%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84node%2F</url>
    <content type="text"><![CDATA[安装NVM前提是安装了homebrew 1$ brew install nvm 在终端中输入以下命令 1$ vim ~/.zshrc 然后添加以下命令 12export NVM_DIR=&quot;$HOME/.nvm&quot;. &quot;/usr/local/opt/nvm/nvm.sh&quot; 最后推出vim，输入以下命令 1$ source ~/.zshrc 使用nvm安装指定版本的node1234567$ nvm ls-remote 查看 所有的node可用版本$ nvm install 8.9.4 下载你想要的版本,这里的8.9.4指的是node的版本$ nvm use 8.9.4 使用指定版本的node $ nvm alias default 8.9.4 每次启动终端都使用该版本的node 查看你的node和npm的版本123$ node -v$ npm -v 查看npm全局安装的modules(模块)1$ npm list --depth=0 -global]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 程序猿软件推荐一波]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[Web编程软件 WebStorm VS Code Sublime Text 使用过程中，我感觉WebStorm和VS Code所占用的内存差不多，但是个人认为还是WebStorm会更好一点，Sublime可以用来快速的查看代码,顺便安利一波使用命令开启VS Code和Sublime来打开项目 VS Code通过终端输入下面命令 1$ vim ~/.zshrc 在把下面命令加上 1234567alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos;alias subl=&quot;&apos;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&apos;&quot;alias nano=&quot;subl&quot;export EDITOR=&quot;subl&quot; 代码版本控制可视化工具 svn: Cornerstone git: Sourcetree HomebrewmacOS 缺失的软件包管理器打开终端输入以下命令 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 其他开发利器 终端: iTerm Docker 软件快速切换: Alfred SSH: Termius 视频播放器: IINA FTP: FileZilla Mac清理软件: Dr. Cleaner]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 使用Promise封装wx.request]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85wx-request%2F</url>
    <content type="text"><![CDATA[wx.request微信小程序原生的网络请求API 12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) Promise使用Promise封装wx.request,在发起一个请求之前使用wx.showToast()，在接口调用结束的complete回调函数中使用wx.hideToast() 1234567891011121314151617181920212223242526272829303132const wxRequest = (params = &#123;&#125;, url) =&gt; &#123; wx.showToast(&#123; title: '加载中...', icon: 'loading', duration: 5000 &#125;) let data = params.query || &#123;&#125;; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: url, method: params.method || 'GET', data: data, header: &#123; 'Content-Type': 'application/json' &#125;, success: res=&gt; &#123; if (res.data.status == 'success') &#123; resolve(res.data) &#125; else &#123; reject(res.msg) &#125; &#125;, complete:()=&gt;&#123; wx.hideToast() &#125;, error: e=&gt; &#123; reject(e) &#125; &#125;) &#125;)&#125;module.exports = &#123; wxRequest,&#125; 如何使用编写一个项目的时候，最好把所有的API接口集合一个js文件中 123456789101112const http = require("../utils/http.js")const baseUrl = 'http://127.0.0.1:8888/Wxxcx'const getUnionId = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getWxUserInfo`)const getLatLng = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getStationList`)const getOil = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getOilGun`)module.exports = &#123; getUnionId, getLatLng, getOil&#125; 接着，在pages中对应页面的js文件中引入 1234567891011121314const api = require('../../api/api.js')在对应的生命周期函数中写入api.getUnionId(&#123; query: &#123; code: app.globalData.code, iv: res.iv, encryptedData: res.encryptedData &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 参考资料 微信小程序 ECMAScript 6 入门]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
