<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[客户端使用七牛云上传文件]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[客户端上传文件首先从后台后去七牛云的token,这里使用node来获取token 123456789101112const getUploadToken = () =&gt; &#123; const accessKey = 'accessKey'; const secretKey = 'secretKey'; const bucket = "bucket"; //存储空间名称 const mac = new qiniu.auth.digest.Mac(accessKey, secretKey); const options = &#123; scope: bucket &#125; const putPolicy = new qiniu.rs.PutPolicy(options); const uploadToken = putPolicy.uploadToken(mac); return uploadToken;&#125; 接着再浏览器请求接口获取七牛云token，进行文件上传12345678910111213141516171819202122232425262728293031&lt;!--使用的vue+elementUI--&gt;qiniuUpload() &#123; this.axios.get("/api/work/getQiniuToken").then(res =&gt; &#123; let token = res.token; let config = &#123; useCdnDomain: true, region: qiniu.region.z1 &#125;; let putExtra = &#123; fname: "", params: &#123;&#125;, mimeType: null &#125;; let file = this.form.audio[0].raw; let key = dayjs().format("YYYYMMDDHHmmssSSS") + ".mp3"; let observable = qiniu.upload(file, key, token, putExtra, config); let that = this; let observer = &#123; next: res =&gt; &#123; console.log(res); &#125;, error: err =&gt; &#123; console.log(err); &#125;, complete: res =&gt; &#123; that.submitForm(res.key); &#125; &#125;; let subscription = observable.subscribe(observer); &#125;);&#125;,]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>nestjs</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nestjs使用配置文件连接数据库]]></title>
    <url>%2F2019%2F05%2F08%2Fnestjs%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[安装12$ npm i --save dotenv$ npm i --save-dev @types/dotenv 创建一个.env文件123456DB_HOST=localhostDB_PORT=3306DB_USETNAME=rootDB_PASSWORD=123456DB_DATABASE=testDB_SYNC=true 全局引入12&lt;!--main.ts--&gt;import 'dotenv/config' 连接数据库1234567891011121314151617&lt;!--app.moudle.ts--&gt;@Module(&#123; imports: [ TypeOrmModule.forRoot(&#123; type: 'mysql', host: process.env.DB_HOST, port: parseInt(process.env.DB_PORT), username: process.env.DB_USETNAME, password: process.env.DB_PASSWORD, database: process.env.DB_DATABASE, entities: [__dirname + '/**/*.entity&#123;.ts,.js&#125;'], synchronize: process.env.DB_SYNC=='true'?true:false, logging: true &#125;), ], ...&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>nestjs</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 音频和背景音频的无缝切换播放]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E9%9F%B3%E9%A2%91%E5%92%8C%E8%83%8C%E6%99%AF%E9%9F%B3%E9%A2%91%E7%9A%84%E6%97%A0%E7%BC%9D%E5%88%87%E6%8D%A2%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[音频播放微信小程序目前建议要使用音频的功能，推荐使用通过wx.createInnerAudioContext()创建内部 audio 上下文 InnerAudioContext 对象。 1234567891011121314151617181920212223242526&lt;!--seek：跳转的位置，auto: 是否自动播放--&gt;handleAudio(seek=0,auto=true)&#123; const that=this this.setData(&#123; innerAudioContext: wx.createInnerAudioContext() &#125;) this.data.innerAudioContext.seek(seek) &lt;!--这里的url指的是音频的地址--&gt; this.data.innerAudioContext.src = url if(auto)&#123; this.data.innerAudioContext.autoplay = true &#125; this.data.innerAudioContext.onPlay(() =&gt; &#123; console.log('开始播放') &#125;) this.data.innerAudioContext.onTimeUpdate(()=&gt;&#123; &lt;!--持续更新已播放的进度--&gt; that.setData(&#123; currentTime: that.formatTime(that.data.innerAudioContext.currentTime) &#125;) &#125;) this.data.innerAudioContext.onError((res) =&gt; &#123; console.log(res.errMsg) console.log(res.errCode) &#125;) &#125; 接着在页面生命周期onReady里使用wx.request的success里去调用handleAudio函数。 背景音频播放如果用户离开音频播放页面，如何是音频接着播放，这里就是用到了背景音频。 1234567891011121314151617playBackground()&#123; wx.setStorageSync('work_id', this.data.work_id) if (this.data.innerAudioContext.paused == false) &#123; &lt;!--销毁音频实例--&gt; this.data.innerAudioContext.destroy() const backgroundAudioManager = wx.getBackgroundAudioManager() &lt;!--this.data.work:从API获取的数据--&gt; backgroundAudioManager.title = this.data.work.title backgroundAudioManager.epname = this.data.work.title backgroundAudioManager.singer = this.data.work.author.name backgroundAudioManager.startTime = this.data.innerAudioContext.currentTime backgroundAudioManager.coverImgUrl = this.data.work.author.avatar[0].url // 设置了 src 之后会自动播放 backgroundAudioManager.src = this.data.work.audio[0].url &#125; &#125; 接着在页面生命周期onHide和onUnload里调用playBackground函数。 完整代码wxml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 &lt;!--pages/work/index.wxml--&gt;&lt;view class=&apos;container&apos;&gt; &lt;i-message id=&quot;message&quot; /&gt; &lt;!-- &lt;image class=&apos;poster&apos; src=&quot;&#123;&#123;work.poster[0].url&#125;&#125;&quot; mode=&apos;widthFix&apos;&gt;&lt;/image&gt; --&gt; &lt;image-loader style=&quot;width:100%&quot; default-image=&apos;/assets/images/def_poster.jpg&apos; mode=&apos;widthFix&apos; original-image=&apos;&#123;&#123;work.poster[0].url&#125;&#125;&apos; width=&quot;100%&quot; /&gt; &lt;view class=&apos;active-audio&apos;&gt; &lt;view class=&apos;audio-left&apos;&gt; &lt;!-- &lt;image src=&apos;&#123;&#123;work.author.avatar[0].url&#125;&#125;&apos; mode=&apos;widthFix&apos;&gt;&lt;/image&gt; --&gt; &lt;image-loader style=&quot;width:100%&quot; default-image=&apos;/assets/images/def_avatar.jpg&apos; mode=&apos;widthFix&apos; original-image=&apos;&#123;&#123;work.author.avatar[0].url&#125;&#125;&apos; width=&quot;100%&quot; /&gt; &lt;view class=&apos;play&apos; wx:if=&quot;&#123;&#123;!paly_status&#125;&#125;&quot; bindtap=&apos;play&apos;&gt; &lt;text class=&apos;play-btn&apos;&gt;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;stop&quot; wx:if=&quot;&#123;&#123;paly_status&#125;&#125;&quot; bindtap=&apos;stop&apos;&gt; &lt;text class=&apos;stop-left&apos;&gt;&lt;/text&gt; &lt;text class=&apos;stop-right&apos;&gt;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;audio-right&apos;&gt; &lt;text class=&apos;top&apos;&gt;&#123;&#123;work.title&#125;&#125;&lt;/text&gt; &lt;view class=&apos;bottom&apos;&gt; &lt;text&gt;&#123;&#123;work.author.name&#125;&#125;&lt;/text&gt; &lt;view class=&apos;time&apos; wx:if=&quot;&#123;&#123;duration!=&apos;00:00&apos;&#125;&#125;&quot;&gt; &lt;text&gt;&#123;&#123;currentTime&#125;&#125;/&lt;/text&gt; &lt;text&gt;&#123;&#123;duration&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;youtube&apos;&gt; &lt;text&gt;YouTube:&lt;/text&gt; &lt;text class=&apos;url&apos;&gt;&#123;&#123;work.video_src&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;action&quot;&gt; &lt;view class=&apos;action-item&apos; open-type=&quot;share&quot;&gt; &lt;button bindtap=&quot;handleTapShareButton&quot; open-type=&quot;share&quot; class=&quot;button-share&quot; id=&quot;share-button&quot;&gt; &lt;/button&gt; &lt;label for=&quot;share-button&quot;&gt;&lt;i-icon size=&apos;24&apos; type=&quot;send&quot; /&gt; &lt;text&gt;分享&lt;/text&gt;&lt;/label&gt; &lt;/view&gt; &lt;view class=&apos;action-item&apos; bindtap=&apos;handleCollect&apos;&gt; &lt;i-icon size=&apos;24&apos; type=&quot;&#123;&#123;collect_status?&apos;collection_fill&apos;:&apos;collection&apos;&#125;&#125;&quot; /&gt; &lt;text&gt;&#123;&#123;collect_status?&apos;已收藏&apos;:&apos;收藏&apos;&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/* pages/work/index.wxss */.container &#123; text-align: center; padding: 0 20rpx;&#125;.poster &#123; width: 100%; border-radius: 5px;&#125;.action &#123; display: flex; justify-content: center; margin: 10px 0;&#125;image&#123; border-radius: 5px;&#125;.action-item &#123; margin: 0 20px; display: flex; align-items: center;&#125;.action-item label &#123; display: flex; align-items: center;&#125;.action text &#123; font-size: 18px; color: #515151;&#125;.button-share &#123; display: none;&#125;.youtube &#123; margin-top: 20px; text-align: left;&#125;.youtube .url &#123; word-wrap: break-word; color: rgb(0, 0, 238); text-decoration: underline; margin: 5px;&#125;.active-audio &#123; margin-top: 10px; width: 100%; display: flex; border: 1px solid #e0e0e0; border-radius: 2px;&#125;.audio-left &#123; position: relative; width: 80px; height: 80px;&#125;.audio-left image &#123; border-radius: 0;&#125;.play &#123; position: absolute; top: 25px; left: 25px; border: 1px solid #fff; display: inline-block; height: 30px; width: 30px; border-radius: 50%;&#125;.play-btn &#123; position: absolute; top: 7px; left: 10px; display: inline-block; width: 0; height: 0; border-top: 8px solid transparent; border-left: 12px solid rgba(255, 255, 255, 0.9); border-bottom: 8px solid transparent;&#125;.stop &#123; position: absolute; top: 25px; left: 25px; border: 1px solid #fff; display: inline-block; height: 30px; width: 30px; border-radius: 50%;&#125;.stop-left, .stop-right &#123; position: absolute; top: 9px; display: inline-block; width: 0; height: 0; border-color: rgba(255, 255, 255, 0.9); border-style: solid; border-width: 6px 2px;&#125;.stop-left &#123; left: 9px;&#125;.stop-right &#123; right: 9px;&#125;.audio-right &#123; position: relative; width: calc(100% - 104px); margin: 0 12px; text-align: left; height: 80px;&#125;.audio-right .top &#123; padding-top: 5px; display: -webkit-box; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2;&#125;.bottom &#123; width: 100%; display: flex; justify-content: space-between; font-size: 14px; color: #8b8b8b; position: absolute; bottom: 5px;&#125;.time&#123; font-size: 14px;&#125; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249const utils = require('../../utils/util.js')const &#123; $Message &#125; = require('../../utils/iview/base/index');const app = getApp()// pages/work/index.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; work:&#123;&#125;, work_id:null, collect_status: false, innerAudioContext:null, time:0, duration:"00:00", currentTime:'00:00', paly_status:false &#125;, /** * 根据id获取作品 */ getWork(id=3,seek=0,auto=true)&#123; utils.wxRequest(`/work/$&#123;id&#125;`,&#123; query: &#123; qiniu:true &#125; &#125;) .then(res =&gt; &#123; this.setData(&#123; work:res.data &#125;); this.setData(&#123; time: res.data.time, duration: res.data.formatTime &#125;) // const audioCtx = wx.createAudioContext('myAudio') // audioCtx.play() this.handleAudio(seek,auto) &#125;) &#125;, /** * 格式化事件 */ formatTime(cellValue)&#123; if (cellValue)&#123; let hour = parseInt(cellValue / 3600) let min = parseInt((cellValue - hour * 3600) / 60) min = min &lt; 10 ? '0' + min : min let sec = parseInt(cellValue % 60) sec = sec &lt; 10 ? '0' + sec : sec if (hour &gt; 0) &#123; return hour + ':' + min + ':' + sec &#125; return min + ':' + sec &#125; &#125;, /** * 播放音频 */ handleAudio(seek=0,auto=true)&#123; const that=this this.setData(&#123; innerAudioContext: wx.createInnerAudioContext() &#125;) this.data.innerAudioContext.seek(seek) this.data.innerAudioContext.src = this.data.work.audio[0].url if(auto)&#123; this.data.innerAudioContext.autoplay = true &#125; this.data.innerAudioContext.onPlay(() =&gt; &#123; that.setData(&#123; paly_status:true &#125;) console.log('开始播放') &#125;) this.data.innerAudioContext.onTimeUpdate(()=&gt;&#123; that.setData(&#123; currentTime: that.formatTime(that.data.innerAudioContext.currentTime) &#125;) &#125;) this.data.innerAudioContext.onError((res) =&gt; &#123; console.log(res.errMsg) console.log(res.errCode) &#125;) &#125;, /** * 播放 */ play()&#123; this.data.innerAudioContext.play() this.setData(&#123; paly_status: true &#125;) &#125;, /** * 停止 */ stop()&#123; this.data.innerAudioContext.pause() this.setData(&#123; paly_status: false &#125;) &#125;, /** * 获取收藏状态 */ getCollectByUser(id) &#123; utils.wxRequest(`/user/collect/$&#123;id&#125;`, &#123; method: 'GET', header: &#123; Authorization: 'Bearer ' + app.globalData.token &#125; &#125;).then(res =&gt; &#123; if (res.collect == true) &#123; this.setData(&#123; collect_status: true &#125;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, /** * 收藏操作 */ handleCollect()&#123; utils.wxRequest('/user/collect', &#123; method: 'POST', query: &#123; work_id: this.data.work.id, collect: this.data.collect_status &#125;, header: &#123; Authorization: 'Bearer ' + app.globalData.token &#125; &#125;).then(res =&gt; &#123; this.setData(&#123; collect_status: !this.data.collect_status &#125;) $Message(&#123; content: res.message, duration: 1, type: 'success' &#125;); &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, /** * 后台播放 */ playBackground()&#123; wx.setStorageSync('work_id', this.data.work_id) if (this.data.innerAudioContext.paused == false) &#123; this.data.innerAudioContext.destroy() const backgroundAudioManager = wx.getBackgroundAudioManager() backgroundAudioManager.title = this.data.work.title backgroundAudioManager.epname = this.data.work.title backgroundAudioManager.singer = this.data.work.author.name backgroundAudioManager.startTime = this.data.innerAudioContext.currentTime backgroundAudioManager.coverImgUrl = this.data.work.author.avatar[0].url // 设置了 src 之后会自动播放 backgroundAudioManager.src = this.data.work.audio[0].url &#125; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.setData(&#123; work_id: options.id &#125;) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; this.getCollectByUser(this.data.work_id) &#125;, /** * 生命周期函数--监听页面显示 * 根据storge判断work_id是否相同,再根据后台播放状态判断 */ onShow: function () &#123; const work_id = wx.getStorageSync('work_id')||null if(work_id!=null &amp;&amp; work_id==this.data.work_id)&#123; const backgroundAudioManager = wx.getBackgroundAudioManager() if (backgroundAudioManager.paused==false)&#123; backgroundAudioManager.pause() this.getWork(this.data.work_id, backgroundAudioManager.currentTime) &#125;else&#123; this.getWork(this.data.work_id) &#125; &#125;else&#123; wx.pauseBackgroundAudio() this.getWork(this.data.work_id) &#125; &#125;, /** * 生命周期函数--监听页面隐藏 * 根据audio播放状态去启动后台播放 */ onHide: function () &#123; this.playBackground() &#125;, /** * 根据audio播放状态去启动后台播放 * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; this.playBackground() &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 实际效果 参考资料 微信小程序 ECMAScript 6 入门]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中浅拷贝和深拷贝]]></title>
    <url>%2F2018%2F08%2F02%2Fjavascript%E4%B8%AD%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[javascript的变量类型 基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。 引用类型：存放在堆内存中的对象，变量实际保存的是一个内存地址，这个内存地址指向另一个内存空间。每个空间大小不一样，要根据情况开进行特定的分配。 当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的内存地址，然后再从堆内存中取得所需的数据。 javascript存储对象都是存地址的，所以浅拷贝会导致 arr1 和arr2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 例如：数组拷贝 123456//浅拷贝，双向改变,指向同一片内存空间var arr1 = [1, 2, 3];var arr2 = arr1;arr1[0] = &apos;2&apos;;console.log(arr1); //2,2,3console.log(arr2); //2,2,3 浅拷贝简单的引用复制12345678910111213141516var a = &#123; key1: &quot;11111&quot;&#125;function Copy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125;a.key2 = [&apos;小辉&apos;, &apos;小辉&apos;];var b = Copy(a);b.key2.push(&quot;大辉&quot;);console.log(b.key2); //小辉，小辉，大辉console.log(a.key2); //小辉，小辉，大辉 a对象中key1属性是字符串，key2属性是数组。a拷贝到b，key1、key2属性均顺利拷贝。给b对象的key2属性进行修改时，a对象的key2属性也会随之改变。说明a，b对象上的key2属性指向的是同一个内存地址（x1），当对b对象的key2属性进行修改时，实际上是修改的x1指向的内存空间。 123b.key1 = 1;console.log(b.key1); //1console.log(1.key1); //11111 给b对象的key1属性进行修改时，a对象的key1属性不会改变。这是由于a，b对象的key1属性都是基本数据类型，会直接存储在内存中，b对象的key1的修改不会对a对象的key1产生影响。其在内存的状态，可以用下图来表示。 深拷贝递归遍历123456789101112131415161718function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125;a.key2 = [&apos;小辉&apos;, &apos;小辉&apos;];var b = &#123;&#125;;b = deepCopy(a, b);b.key2.push(&quot;大辉&quot;);alert(b.key2); //小辉，小辉，大辉alert(a.key2); //小辉，小辉 由上可知，修改b的key2数组时，没有使a父对象中的key2数组新增一个值，即子对象没有影响到父对象a中的key2。其存储模式大致如下： Array的slice和concat方法Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。之所以把它放在深拷贝里，是因为它看起来像是深拷贝。而实际上它是浅拷贝。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 例子如下： 1234567var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false，“看起来”像深拷贝console.log(array === array_concat); //false，“看起来”像深拷贝 可以看出，concat和slice返回的不同的数组实例，这与直接的引用复制是不同的。而从另一个例子可以看出Array的concat和slice并不是真正的深复制，数组中的对象元素(Object,Array等)只是复制了引用。如下： 123456789var array = [1, [1,2,3], &#123;name:&quot;array&quot;&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = &quot;array_slice&quot;; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice JSON对象的parse和stringifyJSON对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。 1234567891011121314151617181920//例1var source = &#123; name:&quot;source&quot;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = &quot;target&quot;; //改变target的name属性console.log(source.name); //source console.log(target.name); //targettarget.child.name = &quot;target child&quot;; //改变target的child console.log(source.child.name); //child console.log(target.child.name); //target child//例2var source = &#123; name:function()&#123;console.log(1);&#125;, child:&#123; name:&quot;child&quot; &#125; &#125; var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined//例3var source = &#123; name:function()&#123;console.log(1);&#125;, child:new RegExp(&quot;e&quot;) &#125;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125; 这种方法使用较为简单，可以满足基本的深拷贝需求，而且能够处理JSON格式能表示的所有数据类型，但是对于正则表达式类型、函数类型等无法进行深拷贝(而且会直接丢失相应的值)。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的多个选项卡中共享sessionStorage]]></title>
    <url>%2F2018%2F06%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E4%B8%AA%E9%80%89%E9%A1%B9%E5%8D%A1%E4%B8%AD%E5%85%B1%E4%BA%ABsessionStorage%2F</url>
    <content type="text"><![CDATA[原文：Sharing sessionStorage between tabs for secure multi-tab authentication 使用场景在web项目中，当用户重开一个标签页的时候，需要重新登录。造成这种情况的是登录的标识符存取在session中，标签页之间没有共享session数据。 解决方式发现国外开发者解决的方式是监听storage事件，利用localStorage事件来跨标签页共享sessionStorage。在线例子 123456789101112131415161718192021222324252627282930313233343536// Removed IE support in this demo for the sake of simplicity// 移除对IE浏览器的支持(function () &#123; if (!sessionStorage.length) &#123; // Ask other tabs for session storage // 新开的标签页触发这个事件 localStorage.setItem(&apos;getSessionStorage&apos;, Date.now()); &#125;; window.addEventListener(&apos;storage&apos;, function (event) &#123; //console.log(&apos;storage event&apos;, event); if (event.key == &apos;getSessionStorage&apos;) &#123; // Some tab asked for the sessionStorage -&gt; send it // 已存在的标签页会接收到这个事件 localStorage.setItem(&apos;sessionStorage&apos;, JSON.stringify(sessionStorage)); localStorage.removeItem(&apos;sessionStorage&apos;); &#125; else if (event.key == &apos;sessionStorage&apos; &amp;&amp; !sessionStorage.length) &#123; // sessionStorage is empty -&gt; fill it // 新开启的标签页会收到这个事件 var data = JSON.parse(event.newValue), value; for (key in data) &#123; sessionStorage.setItem(key, data[key]); &#125; showSessionStorage(); &#125; &#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 提交表单后清空表单内的数据]]></title>
    <url>%2F2018%2F06%2F12%2Fvue-%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E5%90%8E%E6%B8%85%E7%A9%BA%E8%A1%A8%E5%8D%95%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[应用场景在使用vue的框架中，常常出现提交完表单之后，data对象中表单的字段的数据还是存在的，做重复表单提交的过程中不是很友好，如果两个表单中存在公用的组件（组件C），如果这个表单（表单A）的数据没有清空，再跳转到另外一个表单（表单B）的时候，表单A上的组件C上的数据会出现到表单B的组件C上。 解决方式参考vue的API文档，发现我们可以通过$options获取初始化的data对象，在表单提交成功之后或者在vue生命周期的beforeDestroy、destroyed中可以通过 1this.form=Object.assign(&#123;&#125;,this.$options.data().form) 来初始化data对象的form字段。具体代码如下：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目中常见的坑]]></title>
    <url>%2F2018%2F05%2F03%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[本地运行跨域问题通过webpack-dev-server的proxy来解决api接口请求跨域的问题，在dev的index.js文件中，设置proxy 123456789proxyTable: &#123; '/api': &#123; target: 'http://baidu.com/', changeOrigin: true, pathRewrite: &#123; '^/api': '/' &#125; &#125;&#125;, 在axios的中设置 1axios.defaults.baseURL = "/api"; vue操作DOM在created()钩子函数执行的时候进行的DOM操作，发现并未进行任何渲染，在查看Vue官方文档中，发现可以在Vue生命周期的created()钩子函数中通过在Vue.nextTick()的回调函数中进行的DOM操作，或者在mounted钩子函数直接进行DOM操作 element uiTable在element ui的table中，如果想去修改某一行的数据，如果直接将它复制给data对象里的一个属性，当修改某个字段时，会发现table里对应某行字段的数据也会发生改变，产生的原因时一个objec引用类型共享一个内存区域的，所以我们就不能直接连等复制，需要重新指向一个新的引用 1234567891011//赋值对象是一个objectthis.objData=Object.assign(&#123;&#125;, row)或this.objData=&#123;...row&#125;//赋值对象是一个arraynewArray = oldArray.slice()或newArray = oldArray.concat()或newArray = [...oldArray] el-table-column中格式化数据，可以通过formatter属性来绑定一个方法去写格式化数据，或者vue的计算属性computed 在每个el-table-column中通过设置min-width来适应不同大小的屏幕 input在el-input中通过添加.native 修饰符来触发input的原生事件 1&lt;el-input @click.native=&quot;handlenClick&quot;&gt;Click Me&lt;/el-input&gt; 修改element样式可以通过新建一个样式文件，在mian.js里引入 mint uiMessage box在用户的反馈中，ios8.1.2的微信浏览器中会出现提示框出现偏离的状况，修复问题中发现.mint-msgbox的样式中transform: translate3d(-50%,-50%,0);没有起作用，通过引入全局样式 1234567.mint-msgbox&#123; max-width: 84%; top: 35%; left: 8%; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 微信JSSDK签名出错在vue-router的对象实例中设置了mode: ‘history’，会在使用this.$router.push跳转需要调用微信JSSDK的页面中，会签名出错，解决的方式有 1234//方案一通过location.href来跳转需要调用微信JSSDK的页面//方案二vue-router使用hash模式 在真机上进行调试通过在main.js引入vConsole.js来查看api接口请求的数据]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装NPM registry管理工具--nrm]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%AE%89%E8%A3%85NPM-registry%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-nrm%2F</url>
    <content type="text"><![CDATA[安装nrm开发的npm registry 管理工具 nrm, 能够查看和切换当前使用的registry。github 1$ npm install -g nrm 查看当前使用的NPM registry123456789$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ 切换NPM registry1$ nrm use cnpm]]></content>
      <categories>
        <category>Mac</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 通过brew安装指定版本的node]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E9%80%9A%E8%BF%87brew%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84node%2F</url>
    <content type="text"><![CDATA[安装NVM前提是安装了homebrew 1$ brew install nvm 在终端中输入以下命令 1$ vim ~/.zshrc 然后添加以下命令 12export NVM_DIR=&quot;$HOME/.nvm&quot;. &quot;/usr/local/opt/nvm/nvm.sh&quot; 最后推出vim，输入以下命令 1$ source ~/.zshrc 使用nvm安装指定版本的node1234567$ nvm ls-remote 查看 所有的node可用版本$ nvm install 8.9.4 下载你想要的版本,这里的8.9.4指的是node的版本$ nvm use 8.9.4 使用指定版本的node $ nvm alias default 8.9.4 每次启动终端都使用该版本的node 查看你的node和npm的版本123$ node -v$ npm -v 查看npm全局安装的modules(模块)1$ npm list --depth=0 -global]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 程序猿软件推荐一波]]></title>
    <url>%2F2018%2F04%2F18%2FMac-%E7%A8%8B%E5%BA%8F%E7%8C%BF%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[Web编程软件 WebStorm VS Code Sublime Text 使用过程中，我感觉WebStorm和VS Code所占用的内存差不多，但是个人认为还是WebStorm会更好一点，Sublime可以用来快速的查看代码,顺便安利一波使用命令开启VS Code和Sublime来打开项目 VS Code通过终端输入下面命令 1$ vim ~/.zshrc 在把下面命令加上 1234567alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos;alias subl=&quot;&apos;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&apos;&quot;alias nano=&quot;subl&quot;export EDITOR=&quot;subl&quot; 代码版本控制可视化工具 svn: Cornerstone git: Sourcetree HomebrewmacOS 缺失的软件包管理器打开终端输入以下命令 1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 其他开发利器 终端: iTerm Docker 软件快速切换: Alfred SSH: Termius 视频播放器: IINA FTP: FileZilla Mac清理软件: Dr. Cleaner]]></content>
      <categories>
        <category>Mac</category>
        <category>Homebrew</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 使用Promise封装API]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85API%2F</url>
    <content type="text"><![CDATA[wx.getUserInfo获取用户信息 123456789wx.getUserInfo(&#123; withCredentials: true, success(res) &#123; console.log(res.userInfo) &#125;, fail(error)&#123; console.log(error) &#125;&#125;) Promise使用Promise封装微信小程序的大部分API，把这个函数写在一个公共js文件下。这里首先创建一个带有’original’参数的匿名函数赋值给promisify，匿名函数里返回一个携带微信小程序原生API需要传参数的’opt’的函数，最终返回一个promise函数实例。1234567891011const promisify = original =&gt; &#123; return function (opt) &#123; return new Promise((resolve, reject) =&gt; &#123; opt = Object.assign(&#123; success: resolve, fail: reject &#125;, opt) original(opt) &#125;) &#125;&#125; 接着，在pages中对应页面的js文件中引入 12345678const utils = require('../../utils/util.js')utils.promisify(wx.getUserInfo)(&#123;withCredentials: true&#125;) .then(res=&gt;&#123; console.log(res) &#125;).catch(error=&gt;&#123; console.log(error) &#125;) 参考资料 微信小程序 ECMAScript 6 入门]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 使用Promise封装wx.request]]></title>
    <url>%2F2018%2F04%2F17%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85wx-request%2F</url>
    <content type="text"><![CDATA[wx.request微信小程序原生的网络请求API 12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) Promise使用Promise封装wx.request,在发起一个请求之前使用wx.showToast()，在接口调用结束的complete回调函数中使用wx.hideToast() 1234567891011121314151617181920212223242526272829303132const wxRequest = (params = &#123;&#125;, url) =&gt; &#123; wx.showToast(&#123; title: '加载中...', icon: 'loading', duration: 5000 &#125;) let data = params.query || &#123;&#125;; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: url, method: params.method || 'GET', data: data, header: &#123; 'Content-Type': 'application/json' &#125;, success: res=&gt; &#123; if (res.data.status == 'success') &#123; resolve(res.data) &#125; else &#123; reject(res.msg) &#125; &#125;, complete:()=&gt;&#123; wx.hideToast() &#125;, error: e=&gt; &#123; reject(e) &#125; &#125;) &#125;)&#125;module.exports = &#123; wxRequest,&#125; 如何使用编写一个项目的时候，最好把所有的API接口集合一个js文件中 123456789101112const http = require("../utils/http.js")const baseUrl = 'http://127.0.0.1:8888/Wxxcx'const getUnionId = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getWxUserInfo`)const getLatLng = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getStationList`)const getOil = (params) =&gt; http.wxRequest(params, `$&#123;baseUrl&#125;/getOilGun`)module.exports = &#123; getUnionId, getLatLng, getOil&#125; 接着，在pages中对应页面的js文件中引入 1234567891011121314const api = require('../../api/api.js')在对应的生命周期函数中写入api.getUnionId(&#123; query: &#123; code: app.globalData.code, iv: res.iv, encryptedData: res.encryptedData &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 参考资料 微信小程序 ECMAScript 6 入门]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
